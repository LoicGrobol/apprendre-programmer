## Compl√©ments

### Immutabilit√© des cha√Ænes de caract√®res

String indexes cannot be reassigned, i.e. the existent parts of the string cannot be modified directly:


```python
string = "hello"
string[-1] = "a"
```

If we have a task to "mask" all vowels from a text, we will need to create a new string based on the old one.

**Practice** Withouth looking at the code in the next cell, can you think of how to do it?


```python
vowels = "aoiue"
text = "This is a sentence that should contain no vowels."

#try it here by yoursel!
```


```python
vowels = "aoiue"
text = "This is a sentence that should contain no vowels."

masked_text = ""
for char in text:
    if char not in vowels:
        masked_text += char
    else:
        masked_text += "*"
print(masked_text)
```

**Practice:** You are given a string `alphabet` that contains all English letters, and a string `text`.


```python
alphabet = "abcdefghijklmnopqrstuvwxyz"
text = "A chessboard appeared, but it was triangular, and so big that only the nearest point could be seen."
```

Write code that makes this string lowercase and deletes punctuations from the text.

```python

```

### Mutabilit√© des listes

Les m√©thodes de listes qu'on a vu **modifient** les listes directement (*in-place*).

```python
ma_liste = ["a"]
ma_liste.append("b")
print(ma_liste)
```

Ce n'√©tait pas le cas des m√©thodes de cha√Ænes de caract√®res

```python
str1 = "a"
print(str.upper(str1))
print(str1)
```

En Python, les `str` sont **immutables** et les listes sont **mutables**. √áa a d'autres cons√©quences
peu intuitives. Comparez ainsi‚ÄØ:

```python
a = 1
b = a
a = a + 1
print("a vaut ", a)
print("b vaut ", b)
```

et

```python
a = [1, 2, 3]
b = a
a[1] = 2713
print("a vaut ", a)
print("b vaut ", b)
```

Pour faire une **copie** ind√©pendante d'une liste, on peut utiliser la fonction `list`‚ÄØ:

```python
a = [1, 2, 3]
b = list(a)
a[1] = 2713
print("a vaut ", a)
print("b vaut ", b)
```

On peut √©galement utiliser ceci‚ÄØ:

```python
a = [1, 2, 3]
b = a[:]  # ‚Üê notez la diff√©rence
a[1] = 2713
print("a vaut ", a)
print("b vaut ", b)
```

## Encore des bigrammes

Voici un texte

```python
text = "It was dark, like the bottom of a well. There was a pattern of skulls and bones around \
the frame, for the sake of appearances; Death could not look himself in the skull in a mirror \
with cherubs and roses around it. The Death of Rats climbed the frame in a scrabble of claws and \
looked at Death expectantly from the top. Quoth fluttered over and pecked briefly at his own \
reflection, on the basis that anything was worth a try. Show me, said Death, show me my thoughts. \
A chessboard appeared, but it was triangular, and so big that only the nearest point could be seen. \
Right on this point was the world - turtle, elephants, the little orbiting sun and all. It was the \
Discworld, which existed only just this side of total improbability and, therefore, in border country. \
In border country the border gets crossed, and sometimes things creep into the universe that have \
rather more on their mind than a better life for their children and a wonderful future in the \
fruit picking and domestic service industries. On every other black or white triangle of the \
chessboard, all the way to infinity, was a small grey shape, rather like an empty hooded robe."
```

<!-- #region -->
1\. √âcrire un programme qui g√©n√®re la liste `unique_words`, qui contient tous les mots du texte,
sans doublons, et en minuscules. Le r√©sultat devrait √™tre le suivant (l'ordre peut √™tre diff√©rent)‚ÄØ:

```python
['a', 'infinity', 'reflection', 'with', 'like', 'big', 'briefly', 'into', 'children', 'which', 'fruit', 'picking', 'there', 'try', 'little', 'around', 'appearances', 'appeared', 'all', 'crossed', 'basis', 'improbability', 'their', 'discworld', 'black', 'to', 'death', 'future', 'only', 'my', 'robe', 'things', 'for', 'it', 'existed', 'said', 'sake', 'sometimes', 'right', 'way', 'that', 'country', 'chessboard', 'quoth', 'well', 'domestic', 'skull', 'wonderful', 'hooded', 'or', 'empty', 'bottom', 'mirror', 'himself', 'rather', 'over', 'every', 'triangle', 'roses', 'border', 'orbiting', 'was', 'from', 'show', 'be', 'pecked', 'bones', 'just', 'universe', 'me', 'triangular', 'gets', 'worth', 'have', 'climbed', 'service', 'fluttered', 'top', 'but', 'grey', 'claws', 'at', 'rats', 'creep', 'own', 'pattern', 'point', 'white', 'than', 'dark', 'therefore', 'frame', 'this', 'not', 'the', 'could', 'mind', 'turtle', 'scrabble', 'better', 'industries', 'looked', 'an', 'cherubs', 'life', 'anything', 'more', 'small', 'and', 'of', 'his', 'on', 'skulls', 'elephants', 'in', 'thoughts', 'seen', 'nearest', 'expectantly', 'other', 'side', 'shape', 'total', 'so', 'world', 'look', 'sun']
```

(√©videmment ne faites pas juste un copier-coller)

<!-- #endregion -->

```python

```

2\. √âcrire un programme qui extrait √† partir de la liste `unique_words` la liste `attested_bigrams`
des bigrammes de caract√®res qui apparaissent dans le texte.

**Indice** Vous pouvez utiliser le code de l'exercice pr√©c√©dent, que vous appliquerez successivement
√† chacun des mots de `unique_words`, en agr√©geant les r√©sultats dans une seule liste, et en vous
assurant de ne pas cr√©er de doublons.


```python

```

3\. Voici une liste des lettres de l'alphabet anglais. Utilisez-la pour g√©n√©rer une liste
`possible_bigrams` de tous les bigrammes de caract√®res th√©oriquement possibles en anglais.


```python
alphabet = "abcdefghijklmnopqrstuvwxyz"
```

4\. √âcrire un programme qui g√©n√®re la liste `unattested_bigrams` des bigrammes de caract√®res
non attest√©s, c'est-√†-dire de tous les bigrammes qui sont possibles, mais qu'on ne trouve pas dans
ce texte.

```python

```

## D'autres fa√ßons d'it√©rer

Deux nouvelles fonctions qu'on utilise tr√®s souvent en Python. On ne va pas y passer beaucoup de
temps tout de suite, mais sachez que √ßa existe, on les rencontrera d'autres fois.

### `enumerate`

```python
liste = ["le", "petit", "chat", "est", "content"]
for truc in enumerate(liste):
    print(truc)
```

La fonction `enumerate`, appliqu√© √† une s√©quence renvoie une **it√©rable** (comme `range`) dont les
√©l√©ments sont des couples `(indice, √©l√©ment)` compos√©s des √©l√©ments de la s√©quence. √áa permet de
remplacer ceci‚ÄØ:

```python
mot = "linguistique"
for i in range(len(mot)):
    print(mot[i], " indice :", i)
```

par ceci

```python
mot = "linguistique"
for couple in enumerate(mot):
    print(couple[1], " indice :", couple[0])
```

qui est *un peu* plus lisible. On peut aussi utiliser la syntaxe suivante, dont on reparlera plus
tard‚ÄØ:

```python
mot = "linguistique"
for idx, lettre in enumerate(mot):
    print(lettre, " indice :", idx)
```

c'est encore plus lisible et c'est le style recommand√© en Python (pour plusieurs raisons, l√† aussi
on en reparlera).

### `zip`

```python
villes = ["Orl√©ans", "Tours", "Nanterre"]
cp = ["45000", "37000", "92000"]
for truc in zip(villes, cp):
    print(truc)
```

`zip` permet d'it√©rer sur plusieurs s√©quences en parall√®le

```python
villes = ["Orl√©ans", "Tours", "Nanterre"]
cp = ["45000", "37000", "92000"]
appreciation = ["cool", "g√©nial", "super"]
for truc in zip(villes, cp, appreciation):
    print(truc)
```

```python
villes = ["Orl√©ans", "Tours", "Nanterre"]
annee = ["1991", "2014", "2021"]
appreciation = ["cool", "g√©nial", "super"]
for truc in zip(villes, annee, appreciation):
    print("O√π:", truc[0], "Quand:", truc[1], "Comment:", truc[2])
```

L√† aussi on peut utiliser cette nouvelle syntaxe pour que ce soit plus lisible‚ÄØ:

```python
villes = ["Orl√©ans", "Tours", "Nanterre"]
annee = ["1991", "2014", "2021"]
appreciation = ["cool", "g√©nial", "super"]
for ou, quand, comment in zip(villes, annee, appreciation):
    print("O√π:", ou, "Quand:", quand, "Comment:", comment)
```

Est-ce que vous voyez comment simuler `enumerate` en utilisant `zip`‚ÄØ?


Un dernier point‚ÄØ: c'est quoi exactement ces √©l√©ments que renvoient `zip` et `enumerate`, √ßa ressemble √† des listes mais avec des parenth√®ses‚ÄØ?

```python
villes = ["Orl√©ans", "Tours", "Nanterre"]
annee = ["1991", "2014", "2021"]
appreciation = ["cool", "g√©nial", "super"]
for truc in zip(villes, annee, appreciation):
    print(type(truc))
```

Ce sont des `tuple`s, effectivement √ßa ressemble √† des listes mais pas tout √† fait. On les retrouvera plus tard‚ÄØ!

## Encore des manipulations de cha√Ænes üò§

Quelques nouvelles m√©thodes de manipulations de cha√Ænes de caract√®res. L√† aussi on les rencontrera
dans le futur‚ÄØ:

### `replace`

`replace` **remplace** une cha√Æne de caract√®re dans une autre‚ÄØ:

```python
message = "Salut poto. √áa fait plaisir de te voir, poto‚ÄØ!"
nouveau_message = str.replace(message, "poto", "Alex")
print(message)
print(nouveau_message)
```

**Entra√Ænement**‚ÄØ: en utilisant les variables ci-dessous, affichez un message de bienvenue pour
chaque personne dans la liste `guests`‚ÄØ:

```python
template = "Salut, [invit√©], ravi‚ãÖe de te rencontrer‚ÄØ!"
guests = ["Glimmer", "Bow", "Catra",]

# √Ä toi de coder !
```

### `split`

`split` d√©coupe, tron√ßonne, une cha√Æne de caract√®res

```python
texte = "You ever have that feeling, where you‚Äôre not sure if you‚Äôre awake or still dreaming?"
tokens = str.split(texte)
print(tokens)
```

C'est une fa√ßon rapide et simple (simpliste‚ÄØ?) de d√©couper un texte en tokens.

Vous pouvez aussi utiliser un autre s√©parateur que les espaces‚ÄØ:

```python
texte = "bleu,rouge,indigo,vert"
colours = str.split(texte, ",")
print(colours)
```

et les s√©parateurs peuvent √™tre des cha√Ænes arbitraires‚ÄØ:

```python
texte = "bleu et rouge et indigo et vert"
colours = str.split(texte, " et ")
print(colours)
```

### `join`

`join`¬†est d'une certaine fa√ßon l'inverse de `split`‚ÄØ:

```python
names = ['Anna', 'Mary', 'John', 'Sebastian']
text = str.join(" and ", names)
print(texte)
```


```python
letters = ['P', 'y', 't', 'h', 'o', 'n']
print(str.join("", letters))
```

### Utiliser les m√©thodes de cha√Æne

Ces m√©thodes peuvent aussi √™tre utilis√©es directement, sans faire appel √† `str`‚ÄØ:

```python
texte = "bleu,rouge,indigo,vert"
colours = str.split(texte, ",")
print(colours)
```

est √©quivalent √†

```python
texte = "bleu,rouge,indigo,vert"
colours = texte.split(",")
print(colours)
```

et

```python
names = ['Anna', 'Mary', 'John', 'Sebastian']
text = str.join(" and ", names)
print(text)
```

√†

```python
names = ['Anna', 'Mary', 'John', 'Sebastian']
text = " and ".join(names)
print(text)
```
