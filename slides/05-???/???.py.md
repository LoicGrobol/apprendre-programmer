---
jupyter:
  jupytext:
    formats: ipynb,md
    split_at_heading: true
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.13.6
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

<!-- LTeX: language=fr -->
<!-- #region slideshow={"slide_type": "slide"} -->
Cours 5â€¯: ???
=============

**LoÃ¯c Grobol** [<lgrobol@parisnanterre.fr>](mailto:lgrobol@parisnanterre.fr)

2022-02-08
<!-- #endregion -->

## ğŸ”„ Exo ğŸ”„

Voici une liste

```python
fruits = ["pomme", "poire", "kiwi", "maracuja"]
```

Demandez Ã  l'utilisateurice un nom de fruit et affichez `"ğŸ˜‹"` s'il est dans la liste et `"ğŸ¤¨"` sinon.

```python

```


## MutabilitÃ©

Les mÃ©thodes qu'on a vu **modifient** les listes directement (*in-place*).

```python
ma_liste = ["a"]
ma_liste.append("b")
print(ma_liste)
```

Ce n'Ã©tait pas le cas des mÃ©thodes de chaÃ®nes de caractÃ¨res

```python
str1 = "a"
print(str.upper(str1))
print(str1)
```

En Python, les `str` sont **immutables** et les listes sont **mutables**. Ã‡a a d'autres consÃ©quences
peu intuitives. Comparez ainsiâ€¯:

```python
a = 1
b = a
a = a+1
print("a vaut ", a)
print("b vaut ", b)
```

et

```python
a = [1, 2, 3]
b = a
a[1] = 2713
print("a vaut ", a)
print("b vaut ", b)
```

Pour faire une **copie** indÃ©pendante d'une liste, on peut utiliser ceci (qu'on expliquera plus en
dÃ©tails plus tard)â€¯:

```python
a = [1, 2, 3]
b = a[:]  # â† notez la diffÃ©rence
a[1] = 2713
print("a vaut ", a)
print("b vaut ", b)
```